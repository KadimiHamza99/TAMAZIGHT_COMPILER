Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> code
Rule 1     code -> azayez taggayt NAME { main }
Rule 2     main -> azayez urkid ilem agejdan ( ) { statements }
Rule 3     statements -> statements statement
Rule 4     statements -> empty
Rule 5     statement -> var_assign
Rule 6     statement -> print_statement
Rule 7     statement -> scanf_statement
Rule 8     statement -> empty
Rule 9     var_assign -> NAME EQUALS expression ;
Rule 10    print_statement -> aru ( expression ) ;
Rule 11    scanf_statement -> efk ( NAME ) ;
Rule 12    expression -> expression MULTIPLY expression
Rule 13    expression -> expression DIVIDE expression
Rule 14    expression -> expression MINUS expression
Rule 15    expression -> expression PLUS expression
Rule 16    expression -> INT
Rule 17    expression -> FLOAT
Rule 18    expression -> STRING
Rule 19    expression -> NAME
Rule 20    empty -> <empty>

Terminals, with rules where they appear

(                    : 2 10 11
)                    : 2 10 11
;                    : 9 10 11
DIVIDE               : 13
EQUALS               : 9
FLOAT                : 17
INT                  : 16
MINUS                : 14
MULTIPLY             : 12
NAME                 : 1 9 11 19
PLUS                 : 15
STRING               : 18
agejdan              : 2
aru                  : 10
azayez               : 1 2
efk                  : 11
error                : 
ilem                 : 2
taggayt              : 1
urkid                : 2
{                    : 1 2
}                    : 1 2

Nonterminals, with rules where they appear

code                 : 0
empty                : 4 8
expression           : 9 10 12 12 13 13 14 14 15 15
main                 : 1
print_statement      : 6
scanf_statement      : 7
statement            : 3
statements           : 2 3
var_assign           : 5

Parsing method: LALR

state 0

    (0) S' -> . code
    (1) code -> . azayez taggayt NAME { main }

    azayez          shift and go to state 2

    code                           shift and go to state 1

state 1

    (0) S' -> code .



state 2

    (1) code -> azayez . taggayt NAME { main }

    taggayt         shift and go to state 3


state 3

    (1) code -> azayez taggayt . NAME { main }

    NAME            shift and go to state 4


state 4

    (1) code -> azayez taggayt NAME . { main }

    {               shift and go to state 5


state 5

    (1) code -> azayez taggayt NAME { . main }
    (2) main -> . azayez urkid ilem agejdan ( ) { statements }

    azayez          shift and go to state 6

    main                           shift and go to state 7

state 6

    (2) main -> azayez . urkid ilem agejdan ( ) { statements }

    urkid           shift and go to state 8


state 7

    (1) code -> azayez taggayt NAME { main . }

    }               shift and go to state 9


state 8

    (2) main -> azayez urkid . ilem agejdan ( ) { statements }

    ilem            shift and go to state 10


state 9

    (1) code -> azayez taggayt NAME { main } .

    $end            reduce using rule 1 (code -> azayez taggayt NAME { main } .)


state 10

    (2) main -> azayez urkid ilem . agejdan ( ) { statements }

    agejdan         shift and go to state 11


state 11

    (2) main -> azayez urkid ilem agejdan . ( ) { statements }

    (               shift and go to state 12


state 12

    (2) main -> azayez urkid ilem agejdan ( . ) { statements }

    )               shift and go to state 13


state 13

    (2) main -> azayez urkid ilem agejdan ( ) . { statements }

    {               shift and go to state 14


state 14

    (2) main -> azayez urkid ilem agejdan ( ) { . statements }
    (3) statements -> . statements statement
    (4) statements -> . empty
    (20) empty -> .

    }               reduce using rule 20 (empty -> .)
    NAME            reduce using rule 20 (empty -> .)
    aru             reduce using rule 20 (empty -> .)
    efk             reduce using rule 20 (empty -> .)

    statements                     shift and go to state 15
    empty                          shift and go to state 16

state 15

    (2) main -> azayez urkid ilem agejdan ( ) { statements . }
    (3) statements -> statements . statement
    (5) statement -> . var_assign
    (6) statement -> . print_statement
    (7) statement -> . scanf_statement
    (8) statement -> . empty
    (9) var_assign -> . NAME EQUALS expression ;
    (10) print_statement -> . aru ( expression ) ;
    (11) scanf_statement -> . efk ( NAME ) ;
    (20) empty -> .

  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for NAME resolved as shift
  ! shift/reduce conflict for aru resolved as shift
  ! shift/reduce conflict for efk resolved as shift
    }               shift and go to state 17
    NAME            shift and go to state 23
    aru             shift and go to state 24
    efk             shift and go to state 25

  ! }               [ reduce using rule 20 (empty -> .) ]
  ! NAME            [ reduce using rule 20 (empty -> .) ]
  ! aru             [ reduce using rule 20 (empty -> .) ]
  ! efk             [ reduce using rule 20 (empty -> .) ]

    statement                      shift and go to state 18
    var_assign                     shift and go to state 19
    print_statement                shift and go to state 20
    scanf_statement                shift and go to state 21
    empty                          shift and go to state 22

state 16

    (4) statements -> empty .

    }               reduce using rule 4 (statements -> empty .)
    NAME            reduce using rule 4 (statements -> empty .)
    aru             reduce using rule 4 (statements -> empty .)
    efk             reduce using rule 4 (statements -> empty .)


state 17

    (2) main -> azayez urkid ilem agejdan ( ) { statements } .

    }               reduce using rule 2 (main -> azayez urkid ilem agejdan ( ) { statements } .)


state 18

    (3) statements -> statements statement .

    }               reduce using rule 3 (statements -> statements statement .)
    NAME            reduce using rule 3 (statements -> statements statement .)
    aru             reduce using rule 3 (statements -> statements statement .)
    efk             reduce using rule 3 (statements -> statements statement .)


state 19

    (5) statement -> var_assign .

    }               reduce using rule 5 (statement -> var_assign .)
    NAME            reduce using rule 5 (statement -> var_assign .)
    aru             reduce using rule 5 (statement -> var_assign .)
    efk             reduce using rule 5 (statement -> var_assign .)


state 20

    (6) statement -> print_statement .

    }               reduce using rule 6 (statement -> print_statement .)
    NAME            reduce using rule 6 (statement -> print_statement .)
    aru             reduce using rule 6 (statement -> print_statement .)
    efk             reduce using rule 6 (statement -> print_statement .)


state 21

    (7) statement -> scanf_statement .

    }               reduce using rule 7 (statement -> scanf_statement .)
    NAME            reduce using rule 7 (statement -> scanf_statement .)
    aru             reduce using rule 7 (statement -> scanf_statement .)
    efk             reduce using rule 7 (statement -> scanf_statement .)


state 22

    (8) statement -> empty .

    }               reduce using rule 8 (statement -> empty .)
    NAME            reduce using rule 8 (statement -> empty .)
    aru             reduce using rule 8 (statement -> empty .)
    efk             reduce using rule 8 (statement -> empty .)


state 23

    (9) var_assign -> NAME . EQUALS expression ;

    EQUALS          shift and go to state 26


state 24

    (10) print_statement -> aru . ( expression ) ;

    (               shift and go to state 27


state 25

    (11) scanf_statement -> efk . ( NAME ) ;

    (               shift and go to state 28


state 26

    (9) var_assign -> NAME EQUALS . expression ;
    (12) expression -> . expression MULTIPLY expression
    (13) expression -> . expression DIVIDE expression
    (14) expression -> . expression MINUS expression
    (15) expression -> . expression PLUS expression
    (16) expression -> . INT
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . NAME

    INT             shift and go to state 31
    FLOAT           shift and go to state 32
    STRING          shift and go to state 33
    NAME            shift and go to state 29

    expression                     shift and go to state 30

state 27

    (10) print_statement -> aru ( . expression ) ;
    (12) expression -> . expression MULTIPLY expression
    (13) expression -> . expression DIVIDE expression
    (14) expression -> . expression MINUS expression
    (15) expression -> . expression PLUS expression
    (16) expression -> . INT
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . NAME

    INT             shift and go to state 31
    FLOAT           shift and go to state 32
    STRING          shift and go to state 33
    NAME            shift and go to state 29

    expression                     shift and go to state 34

state 28

    (11) scanf_statement -> efk ( . NAME ) ;

    NAME            shift and go to state 35


state 29

    (19) expression -> NAME .

    ;               reduce using rule 19 (expression -> NAME .)
    MULTIPLY        reduce using rule 19 (expression -> NAME .)
    DIVIDE          reduce using rule 19 (expression -> NAME .)
    MINUS           reduce using rule 19 (expression -> NAME .)
    PLUS            reduce using rule 19 (expression -> NAME .)
    )               reduce using rule 19 (expression -> NAME .)


state 30

    (9) var_assign -> NAME EQUALS expression . ;
    (12) expression -> expression . MULTIPLY expression
    (13) expression -> expression . DIVIDE expression
    (14) expression -> expression . MINUS expression
    (15) expression -> expression . PLUS expression

    ;               shift and go to state 36
    MULTIPLY        shift and go to state 37
    DIVIDE          shift and go to state 38
    MINUS           shift and go to state 39
    PLUS            shift and go to state 40


state 31

    (16) expression -> INT .

    ;               reduce using rule 16 (expression -> INT .)
    MULTIPLY        reduce using rule 16 (expression -> INT .)
    DIVIDE          reduce using rule 16 (expression -> INT .)
    MINUS           reduce using rule 16 (expression -> INT .)
    PLUS            reduce using rule 16 (expression -> INT .)
    )               reduce using rule 16 (expression -> INT .)


state 32

    (17) expression -> FLOAT .

    ;               reduce using rule 17 (expression -> FLOAT .)
    MULTIPLY        reduce using rule 17 (expression -> FLOAT .)
    DIVIDE          reduce using rule 17 (expression -> FLOAT .)
    MINUS           reduce using rule 17 (expression -> FLOAT .)
    PLUS            reduce using rule 17 (expression -> FLOAT .)
    )               reduce using rule 17 (expression -> FLOAT .)


state 33

    (18) expression -> STRING .

    ;               reduce using rule 18 (expression -> STRING .)
    MULTIPLY        reduce using rule 18 (expression -> STRING .)
    DIVIDE          reduce using rule 18 (expression -> STRING .)
    MINUS           reduce using rule 18 (expression -> STRING .)
    PLUS            reduce using rule 18 (expression -> STRING .)
    )               reduce using rule 18 (expression -> STRING .)


state 34

    (10) print_statement -> aru ( expression . ) ;
    (12) expression -> expression . MULTIPLY expression
    (13) expression -> expression . DIVIDE expression
    (14) expression -> expression . MINUS expression
    (15) expression -> expression . PLUS expression

    )               shift and go to state 41
    MULTIPLY        shift and go to state 37
    DIVIDE          shift and go to state 38
    MINUS           shift and go to state 39
    PLUS            shift and go to state 40


state 35

    (11) scanf_statement -> efk ( NAME . ) ;

    )               shift and go to state 42


state 36

    (9) var_assign -> NAME EQUALS expression ; .

    }               reduce using rule 9 (var_assign -> NAME EQUALS expression ; .)
    NAME            reduce using rule 9 (var_assign -> NAME EQUALS expression ; .)
    aru             reduce using rule 9 (var_assign -> NAME EQUALS expression ; .)
    efk             reduce using rule 9 (var_assign -> NAME EQUALS expression ; .)


state 37

    (12) expression -> expression MULTIPLY . expression
    (12) expression -> . expression MULTIPLY expression
    (13) expression -> . expression DIVIDE expression
    (14) expression -> . expression MINUS expression
    (15) expression -> . expression PLUS expression
    (16) expression -> . INT
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . NAME

    INT             shift and go to state 31
    FLOAT           shift and go to state 32
    STRING          shift and go to state 33
    NAME            shift and go to state 29

    expression                     shift and go to state 43

state 38

    (13) expression -> expression DIVIDE . expression
    (12) expression -> . expression MULTIPLY expression
    (13) expression -> . expression DIVIDE expression
    (14) expression -> . expression MINUS expression
    (15) expression -> . expression PLUS expression
    (16) expression -> . INT
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . NAME

    INT             shift and go to state 31
    FLOAT           shift and go to state 32
    STRING          shift and go to state 33
    NAME            shift and go to state 29

    expression                     shift and go to state 44

state 39

    (14) expression -> expression MINUS . expression
    (12) expression -> . expression MULTIPLY expression
    (13) expression -> . expression DIVIDE expression
    (14) expression -> . expression MINUS expression
    (15) expression -> . expression PLUS expression
    (16) expression -> . INT
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . NAME

    INT             shift and go to state 31
    FLOAT           shift and go to state 32
    STRING          shift and go to state 33
    NAME            shift and go to state 29

    expression                     shift and go to state 45

state 40

    (15) expression -> expression PLUS . expression
    (12) expression -> . expression MULTIPLY expression
    (13) expression -> . expression DIVIDE expression
    (14) expression -> . expression MINUS expression
    (15) expression -> . expression PLUS expression
    (16) expression -> . INT
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . NAME

    INT             shift and go to state 31
    FLOAT           shift and go to state 32
    STRING          shift and go to state 33
    NAME            shift and go to state 29

    expression                     shift and go to state 46

state 41

    (10) print_statement -> aru ( expression ) . ;

    ;               shift and go to state 47


state 42

    (11) scanf_statement -> efk ( NAME ) . ;

    ;               shift and go to state 48


state 43

    (12) expression -> expression MULTIPLY expression .
    (12) expression -> expression . MULTIPLY expression
    (13) expression -> expression . DIVIDE expression
    (14) expression -> expression . MINUS expression
    (15) expression -> expression . PLUS expression

    ;               reduce using rule 12 (expression -> expression MULTIPLY expression .)
    MULTIPLY        reduce using rule 12 (expression -> expression MULTIPLY expression .)
    DIVIDE          reduce using rule 12 (expression -> expression MULTIPLY expression .)
    MINUS           reduce using rule 12 (expression -> expression MULTIPLY expression .)
    PLUS            reduce using rule 12 (expression -> expression MULTIPLY expression .)
    )               reduce using rule 12 (expression -> expression MULTIPLY expression .)

  ! MULTIPLY        [ shift and go to state 37 ]
  ! DIVIDE          [ shift and go to state 38 ]
  ! MINUS           [ shift and go to state 39 ]
  ! PLUS            [ shift and go to state 40 ]


state 44

    (13) expression -> expression DIVIDE expression .
    (12) expression -> expression . MULTIPLY expression
    (13) expression -> expression . DIVIDE expression
    (14) expression -> expression . MINUS expression
    (15) expression -> expression . PLUS expression

    ;               reduce using rule 13 (expression -> expression DIVIDE expression .)
    MULTIPLY        reduce using rule 13 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 13 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 13 (expression -> expression DIVIDE expression .)
    PLUS            reduce using rule 13 (expression -> expression DIVIDE expression .)
    )               reduce using rule 13 (expression -> expression DIVIDE expression .)

  ! MULTIPLY        [ shift and go to state 37 ]
  ! DIVIDE          [ shift and go to state 38 ]
  ! MINUS           [ shift and go to state 39 ]
  ! PLUS            [ shift and go to state 40 ]


state 45

    (14) expression -> expression MINUS expression .
    (12) expression -> expression . MULTIPLY expression
    (13) expression -> expression . DIVIDE expression
    (14) expression -> expression . MINUS expression
    (15) expression -> expression . PLUS expression

    ;               reduce using rule 14 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 14 (expression -> expression MINUS expression .)
    PLUS            reduce using rule 14 (expression -> expression MINUS expression .)
    )               reduce using rule 14 (expression -> expression MINUS expression .)
    MULTIPLY        shift and go to state 37
    DIVIDE          shift and go to state 38

  ! MULTIPLY        [ reduce using rule 14 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 14 (expression -> expression MINUS expression .) ]
  ! MINUS           [ shift and go to state 39 ]
  ! PLUS            [ shift and go to state 40 ]


state 46

    (15) expression -> expression PLUS expression .
    (12) expression -> expression . MULTIPLY expression
    (13) expression -> expression . DIVIDE expression
    (14) expression -> expression . MINUS expression
    (15) expression -> expression . PLUS expression

    ;               reduce using rule 15 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 15 (expression -> expression PLUS expression .)
    PLUS            reduce using rule 15 (expression -> expression PLUS expression .)
    )               reduce using rule 15 (expression -> expression PLUS expression .)
    MULTIPLY        shift and go to state 37
    DIVIDE          shift and go to state 38

  ! MULTIPLY        [ reduce using rule 15 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 15 (expression -> expression PLUS expression .) ]
  ! MINUS           [ shift and go to state 39 ]
  ! PLUS            [ shift and go to state 40 ]


state 47

    (10) print_statement -> aru ( expression ) ; .

    }               reduce using rule 10 (print_statement -> aru ( expression ) ; .)
    NAME            reduce using rule 10 (print_statement -> aru ( expression ) ; .)
    aru             reduce using rule 10 (print_statement -> aru ( expression ) ; .)
    efk             reduce using rule 10 (print_statement -> aru ( expression ) ; .)


state 48

    (11) scanf_statement -> efk ( NAME ) ; .

    }               reduce using rule 11 (scanf_statement -> efk ( NAME ) ; .)
    NAME            reduce using rule 11 (scanf_statement -> efk ( NAME ) ; .)
    aru             reduce using rule 11 (scanf_statement -> efk ( NAME ) ; .)
    efk             reduce using rule 11 (scanf_statement -> efk ( NAME ) ; .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for } in state 15 resolved as shift
WARNING: shift/reduce conflict for NAME in state 15 resolved as shift
WARNING: shift/reduce conflict for aru in state 15 resolved as shift
WARNING: shift/reduce conflict for efk in state 15 resolved as shift
