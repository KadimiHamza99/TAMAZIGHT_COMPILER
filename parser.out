Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> code
Rule 1     code -> encaps taggayt NAME { inner_code } code
Rule 2     code -> empty
Rule 3     encaps -> azayez
Rule 4     encaps -> uslig
Rule 5     encaps -> sehviver
Rule 6     encaps -> empty
Rule 7     inner_code -> attribut_statement functions_statement
Rule 8     inner_code -> attribut_statement
Rule 9     inner_code -> functions_statement
Rule 10    attribut_statement -> encaps NAME ;
Rule 11    functions_statement -> method functions_statement
Rule 12    functions_statement -> main functions_statement
Rule 13    functions_statement -> empty
Rule 14    method -> encaps NAME ( ) { fStates }
Rule 15    fStates -> fState fState
Rule 16    fStates -> empty
Rule 17    fState -> var_assign
Rule 18    fState -> print_statement
Rule 19    fState -> scanf_statement
Rule 20    fState -> if_statement
Rule 21    fState -> loop_control
Rule 22    fState -> empty
Rule 23    main -> encaps urkid ilem agejdan ( ) { statements }
Rule 24    statements -> statement statements
Rule 25    statements -> empty
Rule 26    statement -> var_assign
Rule 27    statement -> print_statement
Rule 28    statement -> call_function
Rule 29    statement -> scanf_statement
Rule 30    statement -> if_statement
Rule 31    statement -> loop_control
Rule 32    statement -> empty
Rule 33    var_assign -> NAME EQUALS expression ;
Rule 34    call_function -> tasekkirt NAME ;
Rule 35    print_statement -> aru ( expression ) ;
Rule 36    scanf_statement -> efk ( NAME ) ;
Rule 37    loop_control -> tamenguct ( INT ) { statementsLoop }
Rule 38    statementsLoop -> statementLoop statementLoop
Rule 39    statementsLoop -> empty
Rule 40    statementLoop -> var_assign
Rule 41    statementLoop -> print_statement
Rule 42    statementLoop -> scanf_statement
Rule 43    statementLoop -> if_statement
Rule 44    statementLoop -> empty
Rule 45    if_statement -> ma ( condition ) { con_statements }
Rule 46    con_statements -> con_statement con_statement con_statement
Rule 47    con_statements -> empty
Rule 48    con_statement -> var_assign
Rule 49    con_statement -> print_statement
Rule 50    con_statement -> scanf_statement
Rule 51    con_statement -> if_statement
Rule 52    con_statement -> empty
Rule 53    condition -> expression comparaison expression
Rule 54    comparaison -> GT
Rule 55    comparaison -> LT
Rule 56    comparaison -> GE
Rule 57    comparaison -> LE
Rule 58    comparaison -> EE
Rule 59    comparaison -> NE
Rule 60    expression -> expression MULTIPLY expression
Rule 61    expression -> expression DIVIDE expression
Rule 62    expression -> expression MINUS expression
Rule 63    expression -> expression PLUS expression
Rule 64    expression -> INT
Rule 65    expression -> FLOAT
Rule 66    expression -> STRING
Rule 67    expression -> NAME
Rule 68    empty -> <empty>

Terminals, with rules where they appear

(                    : 14 23 35 36 37 45
)                    : 14 23 35 36 37 45
;                    : 10 33 34 35 36
DIVIDE               : 61
EE                   : 58
EQUALS               : 33
FLOAT                : 65
GE                   : 56
GT                   : 54
INT                  : 37 64
LE                   : 57
LT                   : 55
MINUS                : 62
MULTIPLY             : 60
NAME                 : 1 10 14 33 34 36 67
NE                   : 59
PLUS                 : 63
STRING               : 66
agejdan              : 23
aru                  : 35
azayez               : 3
efk                  : 36
error                : 
ilem                 : 23
ma                   : 45
sehviver             : 5
taggayt              : 1
tamenguct            : 37
tasekkirt            : 34
urkid                : 23
uslig                : 4
{                    : 1 14 23 37 45
}                    : 1 14 23 37 45

Nonterminals, with rules where they appear

attribut_statement   : 7 8
call_function        : 28
code                 : 1 0
comparaison          : 53
con_statement        : 46 46 46
con_statements       : 45
condition            : 45
empty                : 2 6 13 16 22 25 32 39 44 47 52
encaps               : 1 10 14 23
expression           : 33 35 53 53 60 60 61 61 62 62 63 63
fState               : 15 15
fStates              : 14
functions_statement  : 7 9 11 12
if_statement         : 20 30 43 51
inner_code           : 1
loop_control         : 21 31
main                 : 12
method               : 11
print_statement      : 18 27 41 49
scanf_statement      : 19 29 42 50
statement            : 24
statementLoop        : 38 38
statements           : 23 24
statementsLoop       : 37
var_assign           : 17 26 40 48

Parsing method: LALR

state 0

    (0) S' -> . code
    (1) code -> . encaps taggayt NAME { inner_code } code
    (2) code -> . empty
    (3) encaps -> . azayez
    (4) encaps -> . uslig
    (5) encaps -> . sehviver
    (6) encaps -> . empty
    (68) empty -> .

    azayez          shift and go to state 4
    uslig           shift and go to state 5
    sehviver        shift and go to state 6
    $end            reduce using rule 68 (empty -> .)
    taggayt         reduce using rule 68 (empty -> .)

    code                           shift and go to state 1
    encaps                         shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> code .



state 2

    (1) code -> encaps . taggayt NAME { inner_code } code

    taggayt         shift and go to state 7


state 3

    (2) code -> empty .
    (6) encaps -> empty .

    $end            reduce using rule 2 (code -> empty .)
    taggayt         reduce using rule 6 (encaps -> empty .)


state 4

    (3) encaps -> azayez .

    taggayt         reduce using rule 3 (encaps -> azayez .)
    NAME            reduce using rule 3 (encaps -> azayez .)
    urkid           reduce using rule 3 (encaps -> azayez .)


state 5

    (4) encaps -> uslig .

    taggayt         reduce using rule 4 (encaps -> uslig .)
    NAME            reduce using rule 4 (encaps -> uslig .)
    urkid           reduce using rule 4 (encaps -> uslig .)


state 6

    (5) encaps -> sehviver .

    taggayt         reduce using rule 5 (encaps -> sehviver .)
    NAME            reduce using rule 5 (encaps -> sehviver .)
    urkid           reduce using rule 5 (encaps -> sehviver .)


state 7

    (1) code -> encaps taggayt . NAME { inner_code } code

    NAME            shift and go to state 8


state 8

    (1) code -> encaps taggayt NAME . { inner_code } code

    {               shift and go to state 9


state 9

    (1) code -> encaps taggayt NAME { . inner_code } code
    (7) inner_code -> . attribut_statement functions_statement
    (8) inner_code -> . attribut_statement
    (9) inner_code -> . functions_statement
    (10) attribut_statement -> . encaps NAME ;
    (11) functions_statement -> . method functions_statement
    (12) functions_statement -> . main functions_statement
    (13) functions_statement -> . empty
    (3) encaps -> . azayez
    (4) encaps -> . uslig
    (5) encaps -> . sehviver
    (6) encaps -> . empty
    (14) method -> . encaps NAME ( ) { fStates }
    (23) main -> . encaps urkid ilem agejdan ( ) { statements }
    (68) empty -> .

    azayez          shift and go to state 4
    uslig           shift and go to state 5
    sehviver        shift and go to state 6
    }               reduce using rule 68 (empty -> .)
    NAME            reduce using rule 68 (empty -> .)
    urkid           reduce using rule 68 (empty -> .)

    encaps                         shift and go to state 10
    inner_code                     shift and go to state 11
    attribut_statement             shift and go to state 12
    functions_statement            shift and go to state 13
    method                         shift and go to state 14
    main                           shift and go to state 15
    empty                          shift and go to state 16

state 10

    (10) attribut_statement -> encaps . NAME ;
    (14) method -> encaps . NAME ( ) { fStates }
    (23) main -> encaps . urkid ilem agejdan ( ) { statements }

    NAME            shift and go to state 17
    urkid           shift and go to state 18


state 11

    (1) code -> encaps taggayt NAME { inner_code . } code

    }               shift and go to state 19


state 12

    (7) inner_code -> attribut_statement . functions_statement
    (8) inner_code -> attribut_statement .
    (11) functions_statement -> . method functions_statement
    (12) functions_statement -> . main functions_statement
    (13) functions_statement -> . empty
    (14) method -> . encaps NAME ( ) { fStates }
    (23) main -> . encaps urkid ilem agejdan ( ) { statements }
    (68) empty -> .
    (3) encaps -> . azayez
    (4) encaps -> . uslig
    (5) encaps -> . sehviver
    (6) encaps -> . empty

  ! reduce/reduce conflict for } resolved using rule 8 (inner_code -> attribut_statement .)
    }               reduce using rule 8 (inner_code -> attribut_statement .)
    NAME            reduce using rule 68 (empty -> .)
    urkid           reduce using rule 68 (empty -> .)
    azayez          shift and go to state 4
    uslig           shift and go to state 5
    sehviver        shift and go to state 6

  ! }               [ reduce using rule 68 (empty -> .) ]

    functions_statement            shift and go to state 20
    method                         shift and go to state 14
    main                           shift and go to state 15
    empty                          shift and go to state 16
    encaps                         shift and go to state 21

state 13

    (9) inner_code -> functions_statement .

    }               reduce using rule 9 (inner_code -> functions_statement .)


state 14

    (11) functions_statement -> method . functions_statement
    (11) functions_statement -> . method functions_statement
    (12) functions_statement -> . main functions_statement
    (13) functions_statement -> . empty
    (14) method -> . encaps NAME ( ) { fStates }
    (23) main -> . encaps urkid ilem agejdan ( ) { statements }
    (68) empty -> .
    (3) encaps -> . azayez
    (4) encaps -> . uslig
    (5) encaps -> . sehviver
    (6) encaps -> . empty

    }               reduce using rule 68 (empty -> .)
    NAME            reduce using rule 68 (empty -> .)
    urkid           reduce using rule 68 (empty -> .)
    azayez          shift and go to state 4
    uslig           shift and go to state 5
    sehviver        shift and go to state 6

    method                         shift and go to state 14
    functions_statement            shift and go to state 22
    main                           shift and go to state 15
    empty                          shift and go to state 16
    encaps                         shift and go to state 21

state 15

    (12) functions_statement -> main . functions_statement
    (11) functions_statement -> . method functions_statement
    (12) functions_statement -> . main functions_statement
    (13) functions_statement -> . empty
    (14) method -> . encaps NAME ( ) { fStates }
    (23) main -> . encaps urkid ilem agejdan ( ) { statements }
    (68) empty -> .
    (3) encaps -> . azayez
    (4) encaps -> . uslig
    (5) encaps -> . sehviver
    (6) encaps -> . empty

    }               reduce using rule 68 (empty -> .)
    NAME            reduce using rule 68 (empty -> .)
    urkid           reduce using rule 68 (empty -> .)
    azayez          shift and go to state 4
    uslig           shift and go to state 5
    sehviver        shift and go to state 6

    main                           shift and go to state 15
    functions_statement            shift and go to state 23
    method                         shift and go to state 14
    empty                          shift and go to state 16
    encaps                         shift and go to state 21

state 16

    (13) functions_statement -> empty .
    (6) encaps -> empty .

    }               reduce using rule 13 (functions_statement -> empty .)
    NAME            reduce using rule 6 (encaps -> empty .)
    urkid           reduce using rule 6 (encaps -> empty .)


state 17

    (10) attribut_statement -> encaps NAME . ;
    (14) method -> encaps NAME . ( ) { fStates }

    ;               shift and go to state 24
    (               shift and go to state 25


state 18

    (23) main -> encaps urkid . ilem agejdan ( ) { statements }

    ilem            shift and go to state 26


state 19

    (1) code -> encaps taggayt NAME { inner_code } . code
    (1) code -> . encaps taggayt NAME { inner_code } code
    (2) code -> . empty
    (3) encaps -> . azayez
    (4) encaps -> . uslig
    (5) encaps -> . sehviver
    (6) encaps -> . empty
    (68) empty -> .

    azayez          shift and go to state 4
    uslig           shift and go to state 5
    sehviver        shift and go to state 6
    $end            reduce using rule 68 (empty -> .)
    taggayt         reduce using rule 68 (empty -> .)

    encaps                         shift and go to state 2
    code                           shift and go to state 27
    empty                          shift and go to state 3

state 20

    (7) inner_code -> attribut_statement functions_statement .

    }               reduce using rule 7 (inner_code -> attribut_statement functions_statement .)


state 21

    (14) method -> encaps . NAME ( ) { fStates }
    (23) main -> encaps . urkid ilem agejdan ( ) { statements }

    NAME            shift and go to state 28
    urkid           shift and go to state 18


state 22

    (11) functions_statement -> method functions_statement .

    }               reduce using rule 11 (functions_statement -> method functions_statement .)


state 23

    (12) functions_statement -> main functions_statement .

    }               reduce using rule 12 (functions_statement -> main functions_statement .)


state 24

    (10) attribut_statement -> encaps NAME ; .

    azayez          reduce using rule 10 (attribut_statement -> encaps NAME ; .)
    uslig           reduce using rule 10 (attribut_statement -> encaps NAME ; .)
    sehviver        reduce using rule 10 (attribut_statement -> encaps NAME ; .)
    NAME            reduce using rule 10 (attribut_statement -> encaps NAME ; .)
    urkid           reduce using rule 10 (attribut_statement -> encaps NAME ; .)
    }               reduce using rule 10 (attribut_statement -> encaps NAME ; .)


state 25

    (14) method -> encaps NAME ( . ) { fStates }

    )               shift and go to state 29


state 26

    (23) main -> encaps urkid ilem . agejdan ( ) { statements }

    agejdan         shift and go to state 30


state 27

    (1) code -> encaps taggayt NAME { inner_code } code .

    $end            reduce using rule 1 (code -> encaps taggayt NAME { inner_code } code .)


state 28

    (14) method -> encaps NAME . ( ) { fStates }

    (               shift and go to state 25


state 29

    (14) method -> encaps NAME ( ) . { fStates }

    {               shift and go to state 31


state 30

    (23) main -> encaps urkid ilem agejdan . ( ) { statements }

    (               shift and go to state 32


state 31

    (14) method -> encaps NAME ( ) { . fStates }
    (15) fStates -> . fState fState
    (16) fStates -> . empty
    (17) fState -> . var_assign
    (18) fState -> . print_statement
    (19) fState -> . scanf_statement
    (20) fState -> . if_statement
    (21) fState -> . loop_control
    (22) fState -> . empty
    (68) empty -> .
    (33) var_assign -> . NAME EQUALS expression ;
    (35) print_statement -> . aru ( expression ) ;
    (36) scanf_statement -> . efk ( NAME ) ;
    (45) if_statement -> . ma ( condition ) { con_statements }
    (37) loop_control -> . tamenguct ( INT ) { statementsLoop }

  ! shift/reduce conflict for NAME resolved as shift
  ! shift/reduce conflict for aru resolved as shift
  ! shift/reduce conflict for efk resolved as shift
  ! shift/reduce conflict for ma resolved as shift
  ! shift/reduce conflict for tamenguct resolved as shift
    }               reduce using rule 68 (empty -> .)
    NAME            shift and go to state 33
    aru             shift and go to state 42
    efk             shift and go to state 43
    ma              shift and go to state 44
    tamenguct       shift and go to state 45

  ! NAME            [ reduce using rule 68 (empty -> .) ]
  ! aru             [ reduce using rule 68 (empty -> .) ]
  ! efk             [ reduce using rule 68 (empty -> .) ]
  ! ma              [ reduce using rule 68 (empty -> .) ]
  ! tamenguct       [ reduce using rule 68 (empty -> .) ]

    fStates                        shift and go to state 34
    fState                         shift and go to state 35
    empty                          shift and go to state 36
    var_assign                     shift and go to state 37
    print_statement                shift and go to state 38
    scanf_statement                shift and go to state 39
    if_statement                   shift and go to state 40
    loop_control                   shift and go to state 41

state 32

    (23) main -> encaps urkid ilem agejdan ( . ) { statements }

    )               shift and go to state 46


state 33

    (33) var_assign -> NAME . EQUALS expression ;

    EQUALS          shift and go to state 47


state 34

    (14) method -> encaps NAME ( ) { fStates . }

    }               shift and go to state 48


state 35

    (15) fStates -> fState . fState
    (17) fState -> . var_assign
    (18) fState -> . print_statement
    (19) fState -> . scanf_statement
    (20) fState -> . if_statement
    (21) fState -> . loop_control
    (22) fState -> . empty
    (33) var_assign -> . NAME EQUALS expression ;
    (35) print_statement -> . aru ( expression ) ;
    (36) scanf_statement -> . efk ( NAME ) ;
    (45) if_statement -> . ma ( condition ) { con_statements }
    (37) loop_control -> . tamenguct ( INT ) { statementsLoop }
    (68) empty -> .

    NAME            shift and go to state 33
    aru             shift and go to state 42
    efk             shift and go to state 43
    ma              shift and go to state 44
    tamenguct       shift and go to state 45
    }               reduce using rule 68 (empty -> .)

    fState                         shift and go to state 49
    var_assign                     shift and go to state 37
    print_statement                shift and go to state 38
    scanf_statement                shift and go to state 39
    if_statement                   shift and go to state 40
    loop_control                   shift and go to state 41
    empty                          shift and go to state 50

state 36

    (16) fStates -> empty .
    (22) fState -> empty .

  ! reduce/reduce conflict for } resolved using rule 16 (fStates -> empty .)
    }               reduce using rule 16 (fStates -> empty .)
    NAME            reduce using rule 22 (fState -> empty .)
    aru             reduce using rule 22 (fState -> empty .)
    efk             reduce using rule 22 (fState -> empty .)
    ma              reduce using rule 22 (fState -> empty .)
    tamenguct       reduce using rule 22 (fState -> empty .)

  ! }               [ reduce using rule 22 (fState -> empty .) ]


state 37

    (17) fState -> var_assign .

    NAME            reduce using rule 17 (fState -> var_assign .)
    aru             reduce using rule 17 (fState -> var_assign .)
    efk             reduce using rule 17 (fState -> var_assign .)
    ma              reduce using rule 17 (fState -> var_assign .)
    tamenguct       reduce using rule 17 (fState -> var_assign .)
    }               reduce using rule 17 (fState -> var_assign .)


state 38

    (18) fState -> print_statement .

    NAME            reduce using rule 18 (fState -> print_statement .)
    aru             reduce using rule 18 (fState -> print_statement .)
    efk             reduce using rule 18 (fState -> print_statement .)
    ma              reduce using rule 18 (fState -> print_statement .)
    tamenguct       reduce using rule 18 (fState -> print_statement .)
    }               reduce using rule 18 (fState -> print_statement .)


state 39

    (19) fState -> scanf_statement .

    NAME            reduce using rule 19 (fState -> scanf_statement .)
    aru             reduce using rule 19 (fState -> scanf_statement .)
    efk             reduce using rule 19 (fState -> scanf_statement .)
    ma              reduce using rule 19 (fState -> scanf_statement .)
    tamenguct       reduce using rule 19 (fState -> scanf_statement .)
    }               reduce using rule 19 (fState -> scanf_statement .)


state 40

    (20) fState -> if_statement .

    NAME            reduce using rule 20 (fState -> if_statement .)
    aru             reduce using rule 20 (fState -> if_statement .)
    efk             reduce using rule 20 (fState -> if_statement .)
    ma              reduce using rule 20 (fState -> if_statement .)
    tamenguct       reduce using rule 20 (fState -> if_statement .)
    }               reduce using rule 20 (fState -> if_statement .)


state 41

    (21) fState -> loop_control .

    NAME            reduce using rule 21 (fState -> loop_control .)
    aru             reduce using rule 21 (fState -> loop_control .)
    efk             reduce using rule 21 (fState -> loop_control .)
    ma              reduce using rule 21 (fState -> loop_control .)
    tamenguct       reduce using rule 21 (fState -> loop_control .)
    }               reduce using rule 21 (fState -> loop_control .)


state 42

    (35) print_statement -> aru . ( expression ) ;

    (               shift and go to state 51


state 43

    (36) scanf_statement -> efk . ( NAME ) ;

    (               shift and go to state 52


state 44

    (45) if_statement -> ma . ( condition ) { con_statements }

    (               shift and go to state 53


state 45

    (37) loop_control -> tamenguct . ( INT ) { statementsLoop }

    (               shift and go to state 54


state 46

    (23) main -> encaps urkid ilem agejdan ( ) . { statements }

    {               shift and go to state 55


state 47

    (33) var_assign -> NAME EQUALS . expression ;
    (60) expression -> . expression MULTIPLY expression
    (61) expression -> . expression DIVIDE expression
    (62) expression -> . expression MINUS expression
    (63) expression -> . expression PLUS expression
    (64) expression -> . INT
    (65) expression -> . FLOAT
    (66) expression -> . STRING
    (67) expression -> . NAME

    INT             shift and go to state 58
    FLOAT           shift and go to state 59
    STRING          shift and go to state 60
    NAME            shift and go to state 56

    expression                     shift and go to state 57

state 48

    (14) method -> encaps NAME ( ) { fStates } .

    azayez          reduce using rule 14 (method -> encaps NAME ( ) { fStates } .)
    uslig           reduce using rule 14 (method -> encaps NAME ( ) { fStates } .)
    sehviver        reduce using rule 14 (method -> encaps NAME ( ) { fStates } .)
    NAME            reduce using rule 14 (method -> encaps NAME ( ) { fStates } .)
    urkid           reduce using rule 14 (method -> encaps NAME ( ) { fStates } .)
    }               reduce using rule 14 (method -> encaps NAME ( ) { fStates } .)


state 49

    (15) fStates -> fState fState .

    }               reduce using rule 15 (fStates -> fState fState .)


state 50

    (22) fState -> empty .

    }               reduce using rule 22 (fState -> empty .)


state 51

    (35) print_statement -> aru ( . expression ) ;
    (60) expression -> . expression MULTIPLY expression
    (61) expression -> . expression DIVIDE expression
    (62) expression -> . expression MINUS expression
    (63) expression -> . expression PLUS expression
    (64) expression -> . INT
    (65) expression -> . FLOAT
    (66) expression -> . STRING
    (67) expression -> . NAME

    INT             shift and go to state 58
    FLOAT           shift and go to state 59
    STRING          shift and go to state 60
    NAME            shift and go to state 56

    expression                     shift and go to state 61

state 52

    (36) scanf_statement -> efk ( . NAME ) ;

    NAME            shift and go to state 62


state 53

    (45) if_statement -> ma ( . condition ) { con_statements }
    (53) condition -> . expression comparaison expression
    (60) expression -> . expression MULTIPLY expression
    (61) expression -> . expression DIVIDE expression
    (62) expression -> . expression MINUS expression
    (63) expression -> . expression PLUS expression
    (64) expression -> . INT
    (65) expression -> . FLOAT
    (66) expression -> . STRING
    (67) expression -> . NAME

    INT             shift and go to state 58
    FLOAT           shift and go to state 59
    STRING          shift and go to state 60
    NAME            shift and go to state 56

    condition                      shift and go to state 63
    expression                     shift and go to state 64

state 54

    (37) loop_control -> tamenguct ( . INT ) { statementsLoop }

    INT             shift and go to state 65


state 55

    (23) main -> encaps urkid ilem agejdan ( ) { . statements }
    (24) statements -> . statement statements
    (25) statements -> . empty
    (26) statement -> . var_assign
    (27) statement -> . print_statement
    (28) statement -> . call_function
    (29) statement -> . scanf_statement
    (30) statement -> . if_statement
    (31) statement -> . loop_control
    (32) statement -> . empty
    (68) empty -> .
    (33) var_assign -> . NAME EQUALS expression ;
    (35) print_statement -> . aru ( expression ) ;
    (34) call_function -> . tasekkirt NAME ;
    (36) scanf_statement -> . efk ( NAME ) ;
    (45) if_statement -> . ma ( condition ) { con_statements }
    (37) loop_control -> . tamenguct ( INT ) { statementsLoop }

  ! shift/reduce conflict for NAME resolved as shift
  ! shift/reduce conflict for aru resolved as shift
  ! shift/reduce conflict for tasekkirt resolved as shift
  ! shift/reduce conflict for efk resolved as shift
  ! shift/reduce conflict for ma resolved as shift
  ! shift/reduce conflict for tamenguct resolved as shift
    }               reduce using rule 68 (empty -> .)
    NAME            shift and go to state 33
    aru             shift and go to state 42
    tasekkirt       shift and go to state 75
    efk             shift and go to state 43
    ma              shift and go to state 44
    tamenguct       shift and go to state 45

  ! NAME            [ reduce using rule 68 (empty -> .) ]
  ! aru             [ reduce using rule 68 (empty -> .) ]
  ! tasekkirt       [ reduce using rule 68 (empty -> .) ]
  ! efk             [ reduce using rule 68 (empty -> .) ]
  ! ma              [ reduce using rule 68 (empty -> .) ]
  ! tamenguct       [ reduce using rule 68 (empty -> .) ]

    statements                     shift and go to state 66
    statement                      shift and go to state 67
    empty                          shift and go to state 68
    var_assign                     shift and go to state 69
    print_statement                shift and go to state 70
    call_function                  shift and go to state 71
    scanf_statement                shift and go to state 72
    if_statement                   shift and go to state 73
    loop_control                   shift and go to state 74

state 56

    (67) expression -> NAME .

    ;               reduce using rule 67 (expression -> NAME .)
    MULTIPLY        reduce using rule 67 (expression -> NAME .)
    DIVIDE          reduce using rule 67 (expression -> NAME .)
    MINUS           reduce using rule 67 (expression -> NAME .)
    PLUS            reduce using rule 67 (expression -> NAME .)
    )               reduce using rule 67 (expression -> NAME .)
    GT              reduce using rule 67 (expression -> NAME .)
    LT              reduce using rule 67 (expression -> NAME .)
    GE              reduce using rule 67 (expression -> NAME .)
    LE              reduce using rule 67 (expression -> NAME .)
    EE              reduce using rule 67 (expression -> NAME .)
    NE              reduce using rule 67 (expression -> NAME .)


state 57

    (33) var_assign -> NAME EQUALS expression . ;
    (60) expression -> expression . MULTIPLY expression
    (61) expression -> expression . DIVIDE expression
    (62) expression -> expression . MINUS expression
    (63) expression -> expression . PLUS expression

    ;               shift and go to state 76
    MULTIPLY        shift and go to state 77
    DIVIDE          shift and go to state 78
    MINUS           shift and go to state 79
    PLUS            shift and go to state 80


state 58

    (64) expression -> INT .

    ;               reduce using rule 64 (expression -> INT .)
    MULTIPLY        reduce using rule 64 (expression -> INT .)
    DIVIDE          reduce using rule 64 (expression -> INT .)
    MINUS           reduce using rule 64 (expression -> INT .)
    PLUS            reduce using rule 64 (expression -> INT .)
    )               reduce using rule 64 (expression -> INT .)
    GT              reduce using rule 64 (expression -> INT .)
    LT              reduce using rule 64 (expression -> INT .)
    GE              reduce using rule 64 (expression -> INT .)
    LE              reduce using rule 64 (expression -> INT .)
    EE              reduce using rule 64 (expression -> INT .)
    NE              reduce using rule 64 (expression -> INT .)


state 59

    (65) expression -> FLOAT .

    ;               reduce using rule 65 (expression -> FLOAT .)
    MULTIPLY        reduce using rule 65 (expression -> FLOAT .)
    DIVIDE          reduce using rule 65 (expression -> FLOAT .)
    MINUS           reduce using rule 65 (expression -> FLOAT .)
    PLUS            reduce using rule 65 (expression -> FLOAT .)
    )               reduce using rule 65 (expression -> FLOAT .)
    GT              reduce using rule 65 (expression -> FLOAT .)
    LT              reduce using rule 65 (expression -> FLOAT .)
    GE              reduce using rule 65 (expression -> FLOAT .)
    LE              reduce using rule 65 (expression -> FLOAT .)
    EE              reduce using rule 65 (expression -> FLOAT .)
    NE              reduce using rule 65 (expression -> FLOAT .)


state 60

    (66) expression -> STRING .

    ;               reduce using rule 66 (expression -> STRING .)
    MULTIPLY        reduce using rule 66 (expression -> STRING .)
    DIVIDE          reduce using rule 66 (expression -> STRING .)
    MINUS           reduce using rule 66 (expression -> STRING .)
    PLUS            reduce using rule 66 (expression -> STRING .)
    )               reduce using rule 66 (expression -> STRING .)
    GT              reduce using rule 66 (expression -> STRING .)
    LT              reduce using rule 66 (expression -> STRING .)
    GE              reduce using rule 66 (expression -> STRING .)
    LE              reduce using rule 66 (expression -> STRING .)
    EE              reduce using rule 66 (expression -> STRING .)
    NE              reduce using rule 66 (expression -> STRING .)


state 61

    (35) print_statement -> aru ( expression . ) ;
    (60) expression -> expression . MULTIPLY expression
    (61) expression -> expression . DIVIDE expression
    (62) expression -> expression . MINUS expression
    (63) expression -> expression . PLUS expression

    )               shift and go to state 81
    MULTIPLY        shift and go to state 77
    DIVIDE          shift and go to state 78
    MINUS           shift and go to state 79
    PLUS            shift and go to state 80


state 62

    (36) scanf_statement -> efk ( NAME . ) ;

    )               shift and go to state 82


state 63

    (45) if_statement -> ma ( condition . ) { con_statements }

    )               shift and go to state 83


state 64

    (53) condition -> expression . comparaison expression
    (60) expression -> expression . MULTIPLY expression
    (61) expression -> expression . DIVIDE expression
    (62) expression -> expression . MINUS expression
    (63) expression -> expression . PLUS expression
    (54) comparaison -> . GT
    (55) comparaison -> . LT
    (56) comparaison -> . GE
    (57) comparaison -> . LE
    (58) comparaison -> . EE
    (59) comparaison -> . NE

    MULTIPLY        shift and go to state 77
    DIVIDE          shift and go to state 78
    MINUS           shift and go to state 79
    PLUS            shift and go to state 80
    GT              shift and go to state 85
    LT              shift and go to state 86
    GE              shift and go to state 87
    LE              shift and go to state 88
    EE              shift and go to state 89
    NE              shift and go to state 90

    comparaison                    shift and go to state 84

state 65

    (37) loop_control -> tamenguct ( INT . ) { statementsLoop }

    )               shift and go to state 91


state 66

    (23) main -> encaps urkid ilem agejdan ( ) { statements . }

    }               shift and go to state 92


state 67

    (24) statements -> statement . statements
    (24) statements -> . statement statements
    (25) statements -> . empty
    (26) statement -> . var_assign
    (27) statement -> . print_statement
    (28) statement -> . call_function
    (29) statement -> . scanf_statement
    (30) statement -> . if_statement
    (31) statement -> . loop_control
    (32) statement -> . empty
    (68) empty -> .
    (33) var_assign -> . NAME EQUALS expression ;
    (35) print_statement -> . aru ( expression ) ;
    (34) call_function -> . tasekkirt NAME ;
    (36) scanf_statement -> . efk ( NAME ) ;
    (45) if_statement -> . ma ( condition ) { con_statements }
    (37) loop_control -> . tamenguct ( INT ) { statementsLoop }

  ! shift/reduce conflict for NAME resolved as shift
  ! shift/reduce conflict for aru resolved as shift
  ! shift/reduce conflict for tasekkirt resolved as shift
  ! shift/reduce conflict for efk resolved as shift
  ! shift/reduce conflict for ma resolved as shift
  ! shift/reduce conflict for tamenguct resolved as shift
    }               reduce using rule 68 (empty -> .)
    NAME            shift and go to state 33
    aru             shift and go to state 42
    tasekkirt       shift and go to state 75
    efk             shift and go to state 43
    ma              shift and go to state 44
    tamenguct       shift and go to state 45

  ! NAME            [ reduce using rule 68 (empty -> .) ]
  ! aru             [ reduce using rule 68 (empty -> .) ]
  ! tasekkirt       [ reduce using rule 68 (empty -> .) ]
  ! efk             [ reduce using rule 68 (empty -> .) ]
  ! ma              [ reduce using rule 68 (empty -> .) ]
  ! tamenguct       [ reduce using rule 68 (empty -> .) ]

    statement                      shift and go to state 67
    statements                     shift and go to state 93
    empty                          shift and go to state 68
    var_assign                     shift and go to state 69
    print_statement                shift and go to state 70
    call_function                  shift and go to state 71
    scanf_statement                shift and go to state 72
    if_statement                   shift and go to state 73
    loop_control                   shift and go to state 74

state 68

    (25) statements -> empty .
    (32) statement -> empty .

  ! reduce/reduce conflict for } resolved using rule 25 (statements -> empty .)
    }               reduce using rule 25 (statements -> empty .)
    NAME            reduce using rule 32 (statement -> empty .)
    aru             reduce using rule 32 (statement -> empty .)
    tasekkirt       reduce using rule 32 (statement -> empty .)
    efk             reduce using rule 32 (statement -> empty .)
    ma              reduce using rule 32 (statement -> empty .)
    tamenguct       reduce using rule 32 (statement -> empty .)

  ! }               [ reduce using rule 32 (statement -> empty .) ]


state 69

    (26) statement -> var_assign .

    NAME            reduce using rule 26 (statement -> var_assign .)
    aru             reduce using rule 26 (statement -> var_assign .)
    tasekkirt       reduce using rule 26 (statement -> var_assign .)
    efk             reduce using rule 26 (statement -> var_assign .)
    ma              reduce using rule 26 (statement -> var_assign .)
    tamenguct       reduce using rule 26 (statement -> var_assign .)
    }               reduce using rule 26 (statement -> var_assign .)


state 70

    (27) statement -> print_statement .

    NAME            reduce using rule 27 (statement -> print_statement .)
    aru             reduce using rule 27 (statement -> print_statement .)
    tasekkirt       reduce using rule 27 (statement -> print_statement .)
    efk             reduce using rule 27 (statement -> print_statement .)
    ma              reduce using rule 27 (statement -> print_statement .)
    tamenguct       reduce using rule 27 (statement -> print_statement .)
    }               reduce using rule 27 (statement -> print_statement .)


state 71

    (28) statement -> call_function .

    NAME            reduce using rule 28 (statement -> call_function .)
    aru             reduce using rule 28 (statement -> call_function .)
    tasekkirt       reduce using rule 28 (statement -> call_function .)
    efk             reduce using rule 28 (statement -> call_function .)
    ma              reduce using rule 28 (statement -> call_function .)
    tamenguct       reduce using rule 28 (statement -> call_function .)
    }               reduce using rule 28 (statement -> call_function .)


state 72

    (29) statement -> scanf_statement .

    NAME            reduce using rule 29 (statement -> scanf_statement .)
    aru             reduce using rule 29 (statement -> scanf_statement .)
    tasekkirt       reduce using rule 29 (statement -> scanf_statement .)
    efk             reduce using rule 29 (statement -> scanf_statement .)
    ma              reduce using rule 29 (statement -> scanf_statement .)
    tamenguct       reduce using rule 29 (statement -> scanf_statement .)
    }               reduce using rule 29 (statement -> scanf_statement .)


state 73

    (30) statement -> if_statement .

    NAME            reduce using rule 30 (statement -> if_statement .)
    aru             reduce using rule 30 (statement -> if_statement .)
    tasekkirt       reduce using rule 30 (statement -> if_statement .)
    efk             reduce using rule 30 (statement -> if_statement .)
    ma              reduce using rule 30 (statement -> if_statement .)
    tamenguct       reduce using rule 30 (statement -> if_statement .)
    }               reduce using rule 30 (statement -> if_statement .)


state 74

    (31) statement -> loop_control .

    NAME            reduce using rule 31 (statement -> loop_control .)
    aru             reduce using rule 31 (statement -> loop_control .)
    tasekkirt       reduce using rule 31 (statement -> loop_control .)
    efk             reduce using rule 31 (statement -> loop_control .)
    ma              reduce using rule 31 (statement -> loop_control .)
    tamenguct       reduce using rule 31 (statement -> loop_control .)
    }               reduce using rule 31 (statement -> loop_control .)


state 75

    (34) call_function -> tasekkirt . NAME ;

    NAME            shift and go to state 94


state 76

    (33) var_assign -> NAME EQUALS expression ; .

    NAME            reduce using rule 33 (var_assign -> NAME EQUALS expression ; .)
    aru             reduce using rule 33 (var_assign -> NAME EQUALS expression ; .)
    efk             reduce using rule 33 (var_assign -> NAME EQUALS expression ; .)
    ma              reduce using rule 33 (var_assign -> NAME EQUALS expression ; .)
    tamenguct       reduce using rule 33 (var_assign -> NAME EQUALS expression ; .)
    }               reduce using rule 33 (var_assign -> NAME EQUALS expression ; .)
    tasekkirt       reduce using rule 33 (var_assign -> NAME EQUALS expression ; .)


state 77

    (60) expression -> expression MULTIPLY . expression
    (60) expression -> . expression MULTIPLY expression
    (61) expression -> . expression DIVIDE expression
    (62) expression -> . expression MINUS expression
    (63) expression -> . expression PLUS expression
    (64) expression -> . INT
    (65) expression -> . FLOAT
    (66) expression -> . STRING
    (67) expression -> . NAME

    INT             shift and go to state 58
    FLOAT           shift and go to state 59
    STRING          shift and go to state 60
    NAME            shift and go to state 56

    expression                     shift and go to state 95

state 78

    (61) expression -> expression DIVIDE . expression
    (60) expression -> . expression MULTIPLY expression
    (61) expression -> . expression DIVIDE expression
    (62) expression -> . expression MINUS expression
    (63) expression -> . expression PLUS expression
    (64) expression -> . INT
    (65) expression -> . FLOAT
    (66) expression -> . STRING
    (67) expression -> . NAME

    INT             shift and go to state 58
    FLOAT           shift and go to state 59
    STRING          shift and go to state 60
    NAME            shift and go to state 56

    expression                     shift and go to state 96

state 79

    (62) expression -> expression MINUS . expression
    (60) expression -> . expression MULTIPLY expression
    (61) expression -> . expression DIVIDE expression
    (62) expression -> . expression MINUS expression
    (63) expression -> . expression PLUS expression
    (64) expression -> . INT
    (65) expression -> . FLOAT
    (66) expression -> . STRING
    (67) expression -> . NAME

    INT             shift and go to state 58
    FLOAT           shift and go to state 59
    STRING          shift and go to state 60
    NAME            shift and go to state 56

    expression                     shift and go to state 97

state 80

    (63) expression -> expression PLUS . expression
    (60) expression -> . expression MULTIPLY expression
    (61) expression -> . expression DIVIDE expression
    (62) expression -> . expression MINUS expression
    (63) expression -> . expression PLUS expression
    (64) expression -> . INT
    (65) expression -> . FLOAT
    (66) expression -> . STRING
    (67) expression -> . NAME

    INT             shift and go to state 58
    FLOAT           shift and go to state 59
    STRING          shift and go to state 60
    NAME            shift and go to state 56

    expression                     shift and go to state 98

state 81

    (35) print_statement -> aru ( expression ) . ;

    ;               shift and go to state 99


state 82

    (36) scanf_statement -> efk ( NAME ) . ;

    ;               shift and go to state 100


state 83

    (45) if_statement -> ma ( condition ) . { con_statements }

    {               shift and go to state 101


state 84

    (53) condition -> expression comparaison . expression
    (60) expression -> . expression MULTIPLY expression
    (61) expression -> . expression DIVIDE expression
    (62) expression -> . expression MINUS expression
    (63) expression -> . expression PLUS expression
    (64) expression -> . INT
    (65) expression -> . FLOAT
    (66) expression -> . STRING
    (67) expression -> . NAME

    INT             shift and go to state 58
    FLOAT           shift and go to state 59
    STRING          shift and go to state 60
    NAME            shift and go to state 56

    expression                     shift and go to state 102

state 85

    (54) comparaison -> GT .

    INT             reduce using rule 54 (comparaison -> GT .)
    FLOAT           reduce using rule 54 (comparaison -> GT .)
    STRING          reduce using rule 54 (comparaison -> GT .)
    NAME            reduce using rule 54 (comparaison -> GT .)


state 86

    (55) comparaison -> LT .

    INT             reduce using rule 55 (comparaison -> LT .)
    FLOAT           reduce using rule 55 (comparaison -> LT .)
    STRING          reduce using rule 55 (comparaison -> LT .)
    NAME            reduce using rule 55 (comparaison -> LT .)


state 87

    (56) comparaison -> GE .

    INT             reduce using rule 56 (comparaison -> GE .)
    FLOAT           reduce using rule 56 (comparaison -> GE .)
    STRING          reduce using rule 56 (comparaison -> GE .)
    NAME            reduce using rule 56 (comparaison -> GE .)


state 88

    (57) comparaison -> LE .

    INT             reduce using rule 57 (comparaison -> LE .)
    FLOAT           reduce using rule 57 (comparaison -> LE .)
    STRING          reduce using rule 57 (comparaison -> LE .)
    NAME            reduce using rule 57 (comparaison -> LE .)


state 89

    (58) comparaison -> EE .

    INT             reduce using rule 58 (comparaison -> EE .)
    FLOAT           reduce using rule 58 (comparaison -> EE .)
    STRING          reduce using rule 58 (comparaison -> EE .)
    NAME            reduce using rule 58 (comparaison -> EE .)


state 90

    (59) comparaison -> NE .

    INT             reduce using rule 59 (comparaison -> NE .)
    FLOAT           reduce using rule 59 (comparaison -> NE .)
    STRING          reduce using rule 59 (comparaison -> NE .)
    NAME            reduce using rule 59 (comparaison -> NE .)


state 91

    (37) loop_control -> tamenguct ( INT ) . { statementsLoop }

    {               shift and go to state 103


state 92

    (23) main -> encaps urkid ilem agejdan ( ) { statements } .

    azayez          reduce using rule 23 (main -> encaps urkid ilem agejdan ( ) { statements } .)
    uslig           reduce using rule 23 (main -> encaps urkid ilem agejdan ( ) { statements } .)
    sehviver        reduce using rule 23 (main -> encaps urkid ilem agejdan ( ) { statements } .)
    NAME            reduce using rule 23 (main -> encaps urkid ilem agejdan ( ) { statements } .)
    urkid           reduce using rule 23 (main -> encaps urkid ilem agejdan ( ) { statements } .)
    }               reduce using rule 23 (main -> encaps urkid ilem agejdan ( ) { statements } .)


state 93

    (24) statements -> statement statements .

    }               reduce using rule 24 (statements -> statement statements .)


state 94

    (34) call_function -> tasekkirt NAME . ;

    ;               shift and go to state 104


state 95

    (60) expression -> expression MULTIPLY expression .
    (60) expression -> expression . MULTIPLY expression
    (61) expression -> expression . DIVIDE expression
    (62) expression -> expression . MINUS expression
    (63) expression -> expression . PLUS expression

    ;               reduce using rule 60 (expression -> expression MULTIPLY expression .)
    MULTIPLY        reduce using rule 60 (expression -> expression MULTIPLY expression .)
    DIVIDE          reduce using rule 60 (expression -> expression MULTIPLY expression .)
    MINUS           reduce using rule 60 (expression -> expression MULTIPLY expression .)
    PLUS            reduce using rule 60 (expression -> expression MULTIPLY expression .)
    )               reduce using rule 60 (expression -> expression MULTIPLY expression .)
    GT              reduce using rule 60 (expression -> expression MULTIPLY expression .)
    LT              reduce using rule 60 (expression -> expression MULTIPLY expression .)
    GE              reduce using rule 60 (expression -> expression MULTIPLY expression .)
    LE              reduce using rule 60 (expression -> expression MULTIPLY expression .)
    EE              reduce using rule 60 (expression -> expression MULTIPLY expression .)
    NE              reduce using rule 60 (expression -> expression MULTIPLY expression .)

  ! MULTIPLY        [ shift and go to state 77 ]
  ! DIVIDE          [ shift and go to state 78 ]
  ! MINUS           [ shift and go to state 79 ]
  ! PLUS            [ shift and go to state 80 ]


state 96

    (61) expression -> expression DIVIDE expression .
    (60) expression -> expression . MULTIPLY expression
    (61) expression -> expression . DIVIDE expression
    (62) expression -> expression . MINUS expression
    (63) expression -> expression . PLUS expression

    ;               reduce using rule 61 (expression -> expression DIVIDE expression .)
    MULTIPLY        reduce using rule 61 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 61 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 61 (expression -> expression DIVIDE expression .)
    PLUS            reduce using rule 61 (expression -> expression DIVIDE expression .)
    )               reduce using rule 61 (expression -> expression DIVIDE expression .)
    GT              reduce using rule 61 (expression -> expression DIVIDE expression .)
    LT              reduce using rule 61 (expression -> expression DIVIDE expression .)
    GE              reduce using rule 61 (expression -> expression DIVIDE expression .)
    LE              reduce using rule 61 (expression -> expression DIVIDE expression .)
    EE              reduce using rule 61 (expression -> expression DIVIDE expression .)
    NE              reduce using rule 61 (expression -> expression DIVIDE expression .)

  ! MULTIPLY        [ shift and go to state 77 ]
  ! DIVIDE          [ shift and go to state 78 ]
  ! MINUS           [ shift and go to state 79 ]
  ! PLUS            [ shift and go to state 80 ]


state 97

    (62) expression -> expression MINUS expression .
    (60) expression -> expression . MULTIPLY expression
    (61) expression -> expression . DIVIDE expression
    (62) expression -> expression . MINUS expression
    (63) expression -> expression . PLUS expression

    ;               reduce using rule 62 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 62 (expression -> expression MINUS expression .)
    PLUS            reduce using rule 62 (expression -> expression MINUS expression .)
    )               reduce using rule 62 (expression -> expression MINUS expression .)
    GT              reduce using rule 62 (expression -> expression MINUS expression .)
    LT              reduce using rule 62 (expression -> expression MINUS expression .)
    GE              reduce using rule 62 (expression -> expression MINUS expression .)
    LE              reduce using rule 62 (expression -> expression MINUS expression .)
    EE              reduce using rule 62 (expression -> expression MINUS expression .)
    NE              reduce using rule 62 (expression -> expression MINUS expression .)
    MULTIPLY        shift and go to state 77
    DIVIDE          shift and go to state 78

  ! MULTIPLY        [ reduce using rule 62 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 62 (expression -> expression MINUS expression .) ]
  ! MINUS           [ shift and go to state 79 ]
  ! PLUS            [ shift and go to state 80 ]


state 98

    (63) expression -> expression PLUS expression .
    (60) expression -> expression . MULTIPLY expression
    (61) expression -> expression . DIVIDE expression
    (62) expression -> expression . MINUS expression
    (63) expression -> expression . PLUS expression

    ;               reduce using rule 63 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 63 (expression -> expression PLUS expression .)
    PLUS            reduce using rule 63 (expression -> expression PLUS expression .)
    )               reduce using rule 63 (expression -> expression PLUS expression .)
    GT              reduce using rule 63 (expression -> expression PLUS expression .)
    LT              reduce using rule 63 (expression -> expression PLUS expression .)
    GE              reduce using rule 63 (expression -> expression PLUS expression .)
    LE              reduce using rule 63 (expression -> expression PLUS expression .)
    EE              reduce using rule 63 (expression -> expression PLUS expression .)
    NE              reduce using rule 63 (expression -> expression PLUS expression .)
    MULTIPLY        shift and go to state 77
    DIVIDE          shift and go to state 78

  ! MULTIPLY        [ reduce using rule 63 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 63 (expression -> expression PLUS expression .) ]
  ! MINUS           [ shift and go to state 79 ]
  ! PLUS            [ shift and go to state 80 ]


state 99

    (35) print_statement -> aru ( expression ) ; .

    NAME            reduce using rule 35 (print_statement -> aru ( expression ) ; .)
    aru             reduce using rule 35 (print_statement -> aru ( expression ) ; .)
    efk             reduce using rule 35 (print_statement -> aru ( expression ) ; .)
    ma              reduce using rule 35 (print_statement -> aru ( expression ) ; .)
    tamenguct       reduce using rule 35 (print_statement -> aru ( expression ) ; .)
    }               reduce using rule 35 (print_statement -> aru ( expression ) ; .)
    tasekkirt       reduce using rule 35 (print_statement -> aru ( expression ) ; .)


state 100

    (36) scanf_statement -> efk ( NAME ) ; .

    NAME            reduce using rule 36 (scanf_statement -> efk ( NAME ) ; .)
    aru             reduce using rule 36 (scanf_statement -> efk ( NAME ) ; .)
    efk             reduce using rule 36 (scanf_statement -> efk ( NAME ) ; .)
    ma              reduce using rule 36 (scanf_statement -> efk ( NAME ) ; .)
    tamenguct       reduce using rule 36 (scanf_statement -> efk ( NAME ) ; .)
    }               reduce using rule 36 (scanf_statement -> efk ( NAME ) ; .)
    tasekkirt       reduce using rule 36 (scanf_statement -> efk ( NAME ) ; .)


state 101

    (45) if_statement -> ma ( condition ) { . con_statements }
    (46) con_statements -> . con_statement con_statement con_statement
    (47) con_statements -> . empty
    (48) con_statement -> . var_assign
    (49) con_statement -> . print_statement
    (50) con_statement -> . scanf_statement
    (51) con_statement -> . if_statement
    (52) con_statement -> . empty
    (68) empty -> .
    (33) var_assign -> . NAME EQUALS expression ;
    (35) print_statement -> . aru ( expression ) ;
    (36) scanf_statement -> . efk ( NAME ) ;
    (45) if_statement -> . ma ( condition ) { con_statements }

  ! shift/reduce conflict for NAME resolved as shift
  ! shift/reduce conflict for aru resolved as shift
  ! shift/reduce conflict for efk resolved as shift
  ! shift/reduce conflict for ma resolved as shift
    }               reduce using rule 68 (empty -> .)
    NAME            shift and go to state 33
    aru             shift and go to state 42
    efk             shift and go to state 43
    ma              shift and go to state 44

  ! NAME            [ reduce using rule 68 (empty -> .) ]
  ! aru             [ reduce using rule 68 (empty -> .) ]
  ! efk             [ reduce using rule 68 (empty -> .) ]
  ! ma              [ reduce using rule 68 (empty -> .) ]

    con_statements                 shift and go to state 105
    con_statement                  shift and go to state 106
    empty                          shift and go to state 107
    var_assign                     shift and go to state 108
    print_statement                shift and go to state 109
    scanf_statement                shift and go to state 110
    if_statement                   shift and go to state 111

state 102

    (53) condition -> expression comparaison expression .
    (60) expression -> expression . MULTIPLY expression
    (61) expression -> expression . DIVIDE expression
    (62) expression -> expression . MINUS expression
    (63) expression -> expression . PLUS expression

    )               reduce using rule 53 (condition -> expression comparaison expression .)
    MULTIPLY        shift and go to state 77
    DIVIDE          shift and go to state 78
    MINUS           shift and go to state 79
    PLUS            shift and go to state 80


state 103

    (37) loop_control -> tamenguct ( INT ) { . statementsLoop }
    (38) statementsLoop -> . statementLoop statementLoop
    (39) statementsLoop -> . empty
    (40) statementLoop -> . var_assign
    (41) statementLoop -> . print_statement
    (42) statementLoop -> . scanf_statement
    (43) statementLoop -> . if_statement
    (44) statementLoop -> . empty
    (68) empty -> .
    (33) var_assign -> . NAME EQUALS expression ;
    (35) print_statement -> . aru ( expression ) ;
    (36) scanf_statement -> . efk ( NAME ) ;
    (45) if_statement -> . ma ( condition ) { con_statements }

  ! shift/reduce conflict for NAME resolved as shift
  ! shift/reduce conflict for aru resolved as shift
  ! shift/reduce conflict for efk resolved as shift
  ! shift/reduce conflict for ma resolved as shift
    }               reduce using rule 68 (empty -> .)
    NAME            shift and go to state 33
    aru             shift and go to state 42
    efk             shift and go to state 43
    ma              shift and go to state 44

  ! NAME            [ reduce using rule 68 (empty -> .) ]
  ! aru             [ reduce using rule 68 (empty -> .) ]
  ! efk             [ reduce using rule 68 (empty -> .) ]
  ! ma              [ reduce using rule 68 (empty -> .) ]

    statementsLoop                 shift and go to state 112
    statementLoop                  shift and go to state 113
    empty                          shift and go to state 114
    var_assign                     shift and go to state 115
    print_statement                shift and go to state 116
    scanf_statement                shift and go to state 117
    if_statement                   shift and go to state 118

state 104

    (34) call_function -> tasekkirt NAME ; .

    NAME            reduce using rule 34 (call_function -> tasekkirt NAME ; .)
    aru             reduce using rule 34 (call_function -> tasekkirt NAME ; .)
    tasekkirt       reduce using rule 34 (call_function -> tasekkirt NAME ; .)
    efk             reduce using rule 34 (call_function -> tasekkirt NAME ; .)
    ma              reduce using rule 34 (call_function -> tasekkirt NAME ; .)
    tamenguct       reduce using rule 34 (call_function -> tasekkirt NAME ; .)
    }               reduce using rule 34 (call_function -> tasekkirt NAME ; .)


state 105

    (45) if_statement -> ma ( condition ) { con_statements . }

    }               shift and go to state 119


state 106

    (46) con_statements -> con_statement . con_statement con_statement
    (48) con_statement -> . var_assign
    (49) con_statement -> . print_statement
    (50) con_statement -> . scanf_statement
    (51) con_statement -> . if_statement
    (52) con_statement -> . empty
    (33) var_assign -> . NAME EQUALS expression ;
    (35) print_statement -> . aru ( expression ) ;
    (36) scanf_statement -> . efk ( NAME ) ;
    (45) if_statement -> . ma ( condition ) { con_statements }
    (68) empty -> .

  ! shift/reduce conflict for NAME resolved as shift
  ! shift/reduce conflict for aru resolved as shift
  ! shift/reduce conflict for efk resolved as shift
  ! shift/reduce conflict for ma resolved as shift
    NAME            shift and go to state 33
    aru             shift and go to state 42
    efk             shift and go to state 43
    ma              shift and go to state 44
    }               reduce using rule 68 (empty -> .)

  ! NAME            [ reduce using rule 68 (empty -> .) ]
  ! aru             [ reduce using rule 68 (empty -> .) ]
  ! efk             [ reduce using rule 68 (empty -> .) ]
  ! ma              [ reduce using rule 68 (empty -> .) ]

    con_statement                  shift and go to state 120
    var_assign                     shift and go to state 108
    print_statement                shift and go to state 109
    scanf_statement                shift and go to state 110
    if_statement                   shift and go to state 111
    empty                          shift and go to state 121

state 107

    (47) con_statements -> empty .
    (52) con_statement -> empty .

  ! reduce/reduce conflict for } resolved using rule 47 (con_statements -> empty .)
    }               reduce using rule 47 (con_statements -> empty .)
    NAME            reduce using rule 52 (con_statement -> empty .)
    aru             reduce using rule 52 (con_statement -> empty .)
    efk             reduce using rule 52 (con_statement -> empty .)
    ma              reduce using rule 52 (con_statement -> empty .)

  ! }               [ reduce using rule 52 (con_statement -> empty .) ]


state 108

    (48) con_statement -> var_assign .

    NAME            reduce using rule 48 (con_statement -> var_assign .)
    aru             reduce using rule 48 (con_statement -> var_assign .)
    efk             reduce using rule 48 (con_statement -> var_assign .)
    ma              reduce using rule 48 (con_statement -> var_assign .)
    }               reduce using rule 48 (con_statement -> var_assign .)


state 109

    (49) con_statement -> print_statement .

    NAME            reduce using rule 49 (con_statement -> print_statement .)
    aru             reduce using rule 49 (con_statement -> print_statement .)
    efk             reduce using rule 49 (con_statement -> print_statement .)
    ma              reduce using rule 49 (con_statement -> print_statement .)
    }               reduce using rule 49 (con_statement -> print_statement .)


state 110

    (50) con_statement -> scanf_statement .

    NAME            reduce using rule 50 (con_statement -> scanf_statement .)
    aru             reduce using rule 50 (con_statement -> scanf_statement .)
    efk             reduce using rule 50 (con_statement -> scanf_statement .)
    ma              reduce using rule 50 (con_statement -> scanf_statement .)
    }               reduce using rule 50 (con_statement -> scanf_statement .)


state 111

    (51) con_statement -> if_statement .

    NAME            reduce using rule 51 (con_statement -> if_statement .)
    aru             reduce using rule 51 (con_statement -> if_statement .)
    efk             reduce using rule 51 (con_statement -> if_statement .)
    ma              reduce using rule 51 (con_statement -> if_statement .)
    }               reduce using rule 51 (con_statement -> if_statement .)


state 112

    (37) loop_control -> tamenguct ( INT ) { statementsLoop . }

    }               shift and go to state 122


state 113

    (38) statementsLoop -> statementLoop . statementLoop
    (40) statementLoop -> . var_assign
    (41) statementLoop -> . print_statement
    (42) statementLoop -> . scanf_statement
    (43) statementLoop -> . if_statement
    (44) statementLoop -> . empty
    (33) var_assign -> . NAME EQUALS expression ;
    (35) print_statement -> . aru ( expression ) ;
    (36) scanf_statement -> . efk ( NAME ) ;
    (45) if_statement -> . ma ( condition ) { con_statements }
    (68) empty -> .

    NAME            shift and go to state 33
    aru             shift and go to state 42
    efk             shift and go to state 43
    ma              shift and go to state 44
    }               reduce using rule 68 (empty -> .)

    statementLoop                  shift and go to state 123
    var_assign                     shift and go to state 115
    print_statement                shift and go to state 116
    scanf_statement                shift and go to state 117
    if_statement                   shift and go to state 118
    empty                          shift and go to state 124

state 114

    (39) statementsLoop -> empty .
    (44) statementLoop -> empty .

  ! reduce/reduce conflict for } resolved using rule 39 (statementsLoop -> empty .)
    }               reduce using rule 39 (statementsLoop -> empty .)
    NAME            reduce using rule 44 (statementLoop -> empty .)
    aru             reduce using rule 44 (statementLoop -> empty .)
    efk             reduce using rule 44 (statementLoop -> empty .)
    ma              reduce using rule 44 (statementLoop -> empty .)

  ! }               [ reduce using rule 44 (statementLoop -> empty .) ]


state 115

    (40) statementLoop -> var_assign .

    NAME            reduce using rule 40 (statementLoop -> var_assign .)
    aru             reduce using rule 40 (statementLoop -> var_assign .)
    efk             reduce using rule 40 (statementLoop -> var_assign .)
    ma              reduce using rule 40 (statementLoop -> var_assign .)
    }               reduce using rule 40 (statementLoop -> var_assign .)


state 116

    (41) statementLoop -> print_statement .

    NAME            reduce using rule 41 (statementLoop -> print_statement .)
    aru             reduce using rule 41 (statementLoop -> print_statement .)
    efk             reduce using rule 41 (statementLoop -> print_statement .)
    ma              reduce using rule 41 (statementLoop -> print_statement .)
    }               reduce using rule 41 (statementLoop -> print_statement .)


state 117

    (42) statementLoop -> scanf_statement .

    NAME            reduce using rule 42 (statementLoop -> scanf_statement .)
    aru             reduce using rule 42 (statementLoop -> scanf_statement .)
    efk             reduce using rule 42 (statementLoop -> scanf_statement .)
    ma              reduce using rule 42 (statementLoop -> scanf_statement .)
    }               reduce using rule 42 (statementLoop -> scanf_statement .)


state 118

    (43) statementLoop -> if_statement .

    NAME            reduce using rule 43 (statementLoop -> if_statement .)
    aru             reduce using rule 43 (statementLoop -> if_statement .)
    efk             reduce using rule 43 (statementLoop -> if_statement .)
    ma              reduce using rule 43 (statementLoop -> if_statement .)
    }               reduce using rule 43 (statementLoop -> if_statement .)


state 119

    (45) if_statement -> ma ( condition ) { con_statements } .

    NAME            reduce using rule 45 (if_statement -> ma ( condition ) { con_statements } .)
    aru             reduce using rule 45 (if_statement -> ma ( condition ) { con_statements } .)
    efk             reduce using rule 45 (if_statement -> ma ( condition ) { con_statements } .)
    ma              reduce using rule 45 (if_statement -> ma ( condition ) { con_statements } .)
    tamenguct       reduce using rule 45 (if_statement -> ma ( condition ) { con_statements } .)
    }               reduce using rule 45 (if_statement -> ma ( condition ) { con_statements } .)
    tasekkirt       reduce using rule 45 (if_statement -> ma ( condition ) { con_statements } .)


state 120

    (46) con_statements -> con_statement con_statement . con_statement
    (48) con_statement -> . var_assign
    (49) con_statement -> . print_statement
    (50) con_statement -> . scanf_statement
    (51) con_statement -> . if_statement
    (52) con_statement -> . empty
    (33) var_assign -> . NAME EQUALS expression ;
    (35) print_statement -> . aru ( expression ) ;
    (36) scanf_statement -> . efk ( NAME ) ;
    (45) if_statement -> . ma ( condition ) { con_statements }
    (68) empty -> .

    NAME            shift and go to state 33
    aru             shift and go to state 42
    efk             shift and go to state 43
    ma              shift and go to state 44
    }               reduce using rule 68 (empty -> .)

    con_statement                  shift and go to state 125
    var_assign                     shift and go to state 108
    print_statement                shift and go to state 109
    scanf_statement                shift and go to state 110
    if_statement                   shift and go to state 111
    empty                          shift and go to state 121

state 121

    (52) con_statement -> empty .

    NAME            reduce using rule 52 (con_statement -> empty .)
    aru             reduce using rule 52 (con_statement -> empty .)
    efk             reduce using rule 52 (con_statement -> empty .)
    ma              reduce using rule 52 (con_statement -> empty .)
    }               reduce using rule 52 (con_statement -> empty .)


state 122

    (37) loop_control -> tamenguct ( INT ) { statementsLoop } .

    NAME            reduce using rule 37 (loop_control -> tamenguct ( INT ) { statementsLoop } .)
    aru             reduce using rule 37 (loop_control -> tamenguct ( INT ) { statementsLoop } .)
    efk             reduce using rule 37 (loop_control -> tamenguct ( INT ) { statementsLoop } .)
    ma              reduce using rule 37 (loop_control -> tamenguct ( INT ) { statementsLoop } .)
    tamenguct       reduce using rule 37 (loop_control -> tamenguct ( INT ) { statementsLoop } .)
    }               reduce using rule 37 (loop_control -> tamenguct ( INT ) { statementsLoop } .)
    tasekkirt       reduce using rule 37 (loop_control -> tamenguct ( INT ) { statementsLoop } .)


state 123

    (38) statementsLoop -> statementLoop statementLoop .

    }               reduce using rule 38 (statementsLoop -> statementLoop statementLoop .)


state 124

    (44) statementLoop -> empty .

    }               reduce using rule 44 (statementLoop -> empty .)


state 125

    (46) con_statements -> con_statement con_statement con_statement .

    }               reduce using rule 46 (con_statements -> con_statement con_statement con_statement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NAME in state 31 resolved as shift
WARNING: shift/reduce conflict for aru in state 31 resolved as shift
WARNING: shift/reduce conflict for efk in state 31 resolved as shift
WARNING: shift/reduce conflict for ma in state 31 resolved as shift
WARNING: shift/reduce conflict for tamenguct in state 31 resolved as shift
WARNING: shift/reduce conflict for NAME in state 55 resolved as shift
WARNING: shift/reduce conflict for aru in state 55 resolved as shift
WARNING: shift/reduce conflict for tasekkirt in state 55 resolved as shift
WARNING: shift/reduce conflict for efk in state 55 resolved as shift
WARNING: shift/reduce conflict for ma in state 55 resolved as shift
WARNING: shift/reduce conflict for tamenguct in state 55 resolved as shift
WARNING: shift/reduce conflict for NAME in state 67 resolved as shift
WARNING: shift/reduce conflict for aru in state 67 resolved as shift
WARNING: shift/reduce conflict for tasekkirt in state 67 resolved as shift
WARNING: shift/reduce conflict for efk in state 67 resolved as shift
WARNING: shift/reduce conflict for ma in state 67 resolved as shift
WARNING: shift/reduce conflict for tamenguct in state 67 resolved as shift
WARNING: shift/reduce conflict for NAME in state 101 resolved as shift
WARNING: shift/reduce conflict for aru in state 101 resolved as shift
WARNING: shift/reduce conflict for efk in state 101 resolved as shift
WARNING: shift/reduce conflict for ma in state 101 resolved as shift
WARNING: shift/reduce conflict for NAME in state 103 resolved as shift
WARNING: shift/reduce conflict for aru in state 103 resolved as shift
WARNING: shift/reduce conflict for efk in state 103 resolved as shift
WARNING: shift/reduce conflict for ma in state 103 resolved as shift
WARNING: shift/reduce conflict for NAME in state 106 resolved as shift
WARNING: shift/reduce conflict for aru in state 106 resolved as shift
WARNING: shift/reduce conflict for efk in state 106 resolved as shift
WARNING: shift/reduce conflict for ma in state 106 resolved as shift
WARNING: reduce/reduce conflict in state 12 resolved using rule (inner_code -> attribut_statement)
WARNING: rejected rule (empty -> <empty>) in state 12
WARNING: reduce/reduce conflict in state 36 resolved using rule (fStates -> empty)
WARNING: rejected rule (fState -> empty) in state 36
WARNING: reduce/reduce conflict in state 68 resolved using rule (statements -> empty)
WARNING: rejected rule (statement -> empty) in state 68
WARNING: reduce/reduce conflict in state 107 resolved using rule (con_statements -> empty)
WARNING: rejected rule (con_statement -> empty) in state 107
WARNING: reduce/reduce conflict in state 114 resolved using rule (statementsLoop -> empty)
WARNING: rejected rule (statementLoop -> empty) in state 114
